# 재귀, Map과 Fold

## 이 장의 목표

이 장에서는 알고리즘을 구조화하는 방법으로서 재귀함수를 들여다 볼 것이다. 재귀는 함수형 프로그래밍에서 기본적인 기법이며, 이 책 전체에 걸쳐 사용할 것이다.

PureScript 표준 라이브러리의 함수들도 몇 개 살펴볼 것이다. 특히 `map`과 `fold` 함수들, 그리고 조금 특화된 `filter`나 `concatMap` 함수들을 다룬다.

이번 장을 이끌어갈 예제는 가상의 파일 시스템을 다루기 위한 라이브러리이다. 파일 시스템을 구성하는 파일들의 특성을 계산하는 함수들을 작성하면서 이 장에서 배우게 될 기법들을 적용해 보자.

## 프로젝트 설정

이 장의 소스 코드는 `src/Data/Path.purs`와  `src/FileOperations.purs` 파일이다.

`Data.Path` 모듈에는 가상 파일 시스템의 모델이 정의되어 있다. 이 모듈의 내용을 수정할 일은 없다.

`FileOperations` 모듈에는 `Data.Path`를 사용하는 함수들이 정의되어 있다. 이 장에 포함된 연습 문제를 완성하려면 이 파일을 수정하면 된다.

프로젝트는 다음과 같은 Bower 의존성을 가진다.

- `purescript-maybe`: `Maybe` 타입 생성자가 정의되어 있다.
- `purescript-arrays`: 배열을 사용하기 위한 함수들이 정의되어 있다.
- `purescript-strings`: JavaScript 문자열을 다루기 위한 함수들이 정의되어 있다.
- `purescript-foldable-traversable`: 배열이나 다른 자료 구조들을 폴딩(fold)할 수 있는 함수들이 정의되어 있다.
- `purescript-console`: 콘솔 출력 함수들이 정의되어 있다.

## 시작하기

프로그래밍에서 재귀는 매우 중요한 기법이다. 특히 순수 함수형 프로그래밍에서 더 일반적이다. 그 이유는 재귀를 사용하면 프로그램에서 상태 변경을 줄일 수 있기 때문이다.

재귀는 **분할 정복** 전략(어떤 입력을 처리하려고 할 때 그 입력을 작게 나누어 처리한 다음, 그 부분 결과를 합쳐서 최종 결과를 얻는다.)과도 관련이 깊다.

PureScript에서 재귀의 간단한 예 몇 가지를 보자.

다음은 일반적인 **팩토리얼 함수**이다.

```haskell
fact :: Int -> Int
fact 0 = 1
fact n = n * fact (n - 1)
```

팩토리얼 함수는 문제를 작은 문제로 나누어 풀고 있음을 알 수 있다. 주어진 정수보다 1 작은 정수에 대해 팩토리얼을 계산한다. 0에 도달하면 문제를 더 나눌 필요없이 답이 명확하다.

또다른 보편적 예로서 **피보나찌 함수**를 보자.

```haskell
fib :: Int -> Int
fib 0 = 1
fib 1 = 1
fib n = fib (n - 1) + fib (n - 2)
```

역시 문제를 작은 문제로 나누어 풀고 있다. 이번에는 `fib (n - 1)`과 `fib (n - 2)` 이렇게 두 개의 작은 문제를 먼저 풀어서 각각의 부분 결과를 더한다.

## 배열에 재귀 사용하기

재귀 함수는 `Int` 타입에만 국한되지 않는다. 나중에 **패턴 매칭**을 다룰 때 다양한 데이터 타입에 대해 재귀 함수를 정의하는 방법을 다루게 된다. 하지만 지금은 수나 배열에 대해서만 살펴보기로 하자.

입력이 0이냐 아니냐로 분기한 것과 마찬가지로 배열에 대해서도 입력이 비어있거나 그렇지 않은 경우로 분기한다. 다음 예는 재귀를 사용하여 배열의 길이를 계산하는 함수이다.

```haskell
import Prelude

import Data.Array (null)
import Data.Array.Partial (tail)
import Partial.Unsafe (unsafePartial)

length :: forall a. Array a -> Int
length arr =
  if null arr
    then 0
    else 1 + length (unsafePartial tail arr)
```

이 함수는 배열이 비어있는지 여부에 따라 분기하기 위해 `if .. then .. else` 표현식을 사용하였다. `null` 함수는 배열이 비어있으면 `true`를 반환한다. 빈 배열은 길이가 0이고, 비어 있지 않은 배열은 꼬리(첫 요소를 뺀 나머지 배열)의 길이에 1을 더해서 길이를 계산한다.

이런 식으로 배열의 길이를 구하는 것은 당연히 비효율적이다. 하지만 다음 연습 문제를 푸는데 도움이 될 것이다.

> ## 연습 문제
>
> 1. (쉬움) 입력 값이 짝수이면 `true`를 반환하는 재귀 함수를 작성해 보라.
> 1. (보통) 배열에서 짝수의 갯수를 반환하는 재귀 함수를 작성해 보라. **힌트**: `unsafePartial head`를 사용하면 비어 있지 않은 배열의 첫 요소를 얻어낼 수 있다.(`head`는 `Data.Array.Partial`에서 임포트한다.)

## Map

`map` 함수는 배열에 대한 재귀 함수이다. 배열의 각 요소들에 어떤 함수를 일괄적으로 적용하여 변환하기 위해 사용한다. 즉 배열의 내용을 바꾸기는 하지만 그 모양(배열의 길이)은 그대로 유지한다.

이 책 뒤에서 **타입 클래스**를 다룰 때 보겠지만 `map` 함수는 **펑터(functor)**라고 하는 타입 생성자들의 클래스에 대해 모양을 유지하면서 변환하는 좀더 일반적인 패턴의 한 예이다.

PSCi에서 `map` 함수를 사용해 보자.

```text
$ pulp psci

> import Prelude
> map (\n -> n + 1) [1, 2, 3, 4, 5]
[2, 3, 4, 5, 6]
```

`map` 함수를 사용하는 형태를 보자. 첫 번째 인자로 전달하는 함수는 배열의 각 요소들을 변환할 함수이고, 두 번째 인자로 배열이 전달된다.

## 중위 연산자

`map` 함수를 사용할 때 변환 함수와 배열 사이에 `map`을 넣을 수도 있다. 이 때는 함수 이름을 백틱(`)으로 감싸줘야 한다.

```text
> (\n -> n + 1) `map` [1, 2, 3, 4, 5]
[2, 3, 4, 5, 6]
```

**중위 함수 적용** 문법이다. 어떤 함수라도 이런 식으로 중위 연산자처럼 사용할 수 있다. 대부분은 인자가 두 개 있는 함수에 사용하는 것이 적당하다.

`map` 함수를 배열에 사용하는 경우, 이와 똑같은 역할을 하는 연산자도 있다. `<$>`라고 하는 이 연산자는 다른 이항 연산자들처럼 중위 표기로 사용할 수 있다.

```text
> (\n -> n + 1) <$> [1, 2, 3, 4, 5]
[2, 3, 4, 5, 6]
```

`map`  함수의 타입을 보자.

```text
> :type map
forall a b f. Functor f => (a -> b) -> f a -> f b
```

`map`의 타입을 보면 사실 이 장에서 필요한 것 이상으로 더 일반적이다. 일단 이번 장에서는 `map`의 타입이 다음처럼 덜 일반적인 것으로 보자.

```text
forall a b. (a -> b) -> Array a -> Array b
```

`a`와 `b` 이렇게 두 개의 타입이 결정되어야 `map` 함수를 사용할 수 있다.
`a`는 입력 배열의 요소들 타입이고, `b`는 출력 배열의 요소들 타입이다.
즉 `map`이 배열 요소의 타입을 유지할 필요가 없다는 얘기다. 예를 들어 `map`이나 `<$>`을 사용하여 정수 배열을 문자열 배열로 바꿀 수 있다.

```text
> show <$> [1, 2, 3, 4, 5]

["1","2","3","4","5"]
```

중위 연산자인 `<$>`가 특수 문법인 것처럼 보이긴 하지만 사실 보통의 PureScript 함수에 대한 별칭일 뿐이다. 이 함수가 중위 표현 문법으로 적용되어 있지만 괄호로 감싸서 다른 함수들처럼 사용할 수도 있다. `map` 자리에 `(<$>)`를 넣어도 된다.

```text
> (<$>) show [1, 2, 3, 4, 5]
["1","2","3","4","5"]
```

중위로 표기할 함수들 이름은 기존 함수들에 별칭으로 정의된다.
예를 들어 `Data.Array` 모듈에 정의된 중위 연산자 `(..)`는 `range` 함수의 별칭으로 정의되었다.

```haskell
infix 8 range as ..
```

이제 이 연산자를 다음처럼 사용한다.

```text
> import Data.Array

> 1 .. 5
[1, 2, 3, 4, 5]

> show <$> (1 .. 5)
["1","2","3","4","5"]
```

**주의**: 중위 연산자는 도메인 특정 언어(DSL)을 정의할 때 매우 유용한 도구이다. 하지만 과도하게 사용할 경우 코드를 처음 접하는 이들에게 가독성을 해칠 수 있다. 새로운 연산자를 정의할 때는 신중하게 판단하라.

위 예제에서 `1 .. 5`를 괄호로 감쌌는데, 사실 괄호가 꼭 필요하진 않다. `Data.Array` 모듈에서 `..` 연산자를 정의할 때 `<$>`보다 우선순위를 더 높게 지정했기 때문이다. `..` 연산자를 정의할 때 `infix` 뒤에 8이라고 우선순위를 지정했다. `<$>` 보다 우선순위가 더 높기 때문에 괄호를 사용하지 않아도 된다.


```text
> show <$> 1 .. 5
["1","2","3","4","5"]
```

중위 연산자의 결합 방향(왼쪽/오른쪽)을 지정하고자 할 때는 `infixl`이나 `infixr` 키워드를 사용하면 된다.

## 배열 필터링

`Data.Array` 모듈에는 `filter` 함수도 있다. 주로 `map`과 함께 사용할 수 있다. `filter` 함수는 기존의 배열에서 어떤 조건 함수를 만족시키는 요소들만 뽑아 새로운 배열을 만들어준다.

예를 들어보자. 1부터 10까지의 수 중에서 짝수만으로 구성된 배열을 만들어야 한다면 다음처럼 계산할 수 있다.

```text
> import Data.Array

> filter (\n -> n `mod` 2 == 0) (1 .. 10)
[2,4,6,8,10]
```

> ## 연습 문제
>
> 1. (쉬움) 주어진 숫자 배열로부터 그 제곱들로 된 배열을 계산하는 함수를 `map`이나 `<$>` 함수를 사용하여 작성해보라.
> 1. (쉬움) 주어진 숫자 배열에서 음수를 제거하는 함수를 `filter`를 이용하여 작성해보라.
> 1. (보통) `filter`에 대응하는 `<$?>` 중위 연산자를 정의해보라. 앞 문제를 새로 정의한 연산자로 다시 풀어보라. 이 연산자는 우선순위가 얼마가 되어야 할까? 결합 방향은 어느 쪽이어야 할까? PSCi에서 실험해보라.

## 배열 펼치기

`Data.Array`에 정의된 배열에 관한 표준 함수 중에서 이번에는 `concat`을 살펴보자. `concat`은 배열의 배열을 펼쳐서 단순 배열로 만들어준다.

```text
> import Data.Array

> :type concat
forall a. Array (Array a) -> Array a

> concat [[1, 2, 3], [4, 5], [6]]
[1, 2, 3, 4, 5, 6]
```

`concat` 함수와 관련된 `concatMap`이란 함수도 있다. 이 함수는 이름처럼 `concat`과 `map`을 합쳐놓은 것과 비슷하다. `map`이 인자로 받는 매핑 함수는 배열의 요소를 다른 값(다른 타입도 가능)으로 바꿔주는데 반해 `concatMap`이 인자로 받는 매핑 함수는 배열 요소 하나를 새로운 배열로 만든다.

어떻게 동작하는지 알아보자.

```text
> import Data.Array

> :type concatMap
forall a b. (a -> Array b) -> Array a -> Array b

> concatMap (\n -> [n, n * n]) (1 .. 5)
[1,1,2,4,3,9,4,16,5,25]
```

`concatMap`의 인자로 전달한 `\n -> [n, n * n]` 함수는 정수를 받아서 그 자신과 제곱으로 만들어지는 배열을 반환한다. `concatMap`을 적용한 결과는 1에서 5까지의 값들과 그 제곱값들로 된 10개짜리 배열이다.

`concatMap`은 개별 매핑 결과를 이어붙인다는 점을 알아두자. 매핑 함수를 원본 배열의 각 요소들에 적용시켜서 그 결과로 얻어지는 배열들을 다시 하나의 배열로 만들어 반환한다.

`map`, `filter`, `concatMap`은 배열과 관련된 다양한 함수들, 특히 "배열 다루기"의 근간이 된다.

## 배열 다루기

어떤 숫자 `n`의 약수들을 구하는 문제가 있다고 하자. 단순 무식하게 접근하자면
1부터 `n`까지의 모든 숫자들로 쌍을 만들어서 그 곱이 `n`이 되는지 확인하고, 만약 맞다면 그 쌍을 이루는 두 값이 모두 약수임을 알 수 있다.

이러한 접근 방식을 배열 이해 문법으로 구현할 수 있다. PSCi에서 한 스텝씩 차근차근 진행해보자.

첫 번째 단계는 `n`까지의 숫자들 쌍을 모두 출력하는 것이다. `concatMap`을 이용할 수 있다.

`1 .. n` 배열의 각 숫자들에 대해 `1 .. n`을 매핑시키면 될 것 같다.

```text
> pairs n = concatMap (\i -> 1 .. n) (1 .. n)
```

간단히 3으로 테스트해보자.

```text
> pairs 3
[1,2,3,1,2,3,1,2,3]
```

기대했던 결과가 아니다. 쌍을 구성할 두 번째 값이 그냥 반환되어 버린 것과 같다.
대신 `1 .. n`에 매핑시킬 때 쌍의 첫 번째 값을 사용하면 원하는 전체 쌍을 얻을 수 있을 것이다.

```text
> :paste
… pairs' n =
…   concatMap (\i ->
…     map (\j -> [i, j]) (1 .. n)
…   ) (1 .. n)
… ^D

> pairs' 3
[[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
```

결과가 좀더 그럴듯하다. 그런데 쌍을 너무 많이 만들어낸 것 같다. 이 문제에서 `[1, 2]`나 `[2, 1]`를 모두 생성할 필요는 없다. 두 번째 경우를 무시하기 위해 내부 매핑 범위를 `i`부터 `n`으로 변경하자.

```text
> :paste
… pairs'' n =
…   concatMap (\i ->
…     map (\j -> [i, j]) (i .. n)
…   ) (1 .. n)
… ^D
> pairs'' 3
[[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]]
```

멋지다. 이 함수를 통해 우리는 약수가 될 후보들의 쌍들을 모두 찾을 수 있다.
이제 여기에 `filter`를 적용하여 곱이 `n`이 되는 것만 가려내자.

```text
> import Data.Foldable

> factors n = filter (\pair -> product pair == n) (pairs'' n)

> factors 10
[[1,10],[2,5]]
```

`Data.Foldable` 모듈에 정의된 `product` 함수를 이용했다. (이 모듈은 `purescript-foldable-traversable` 라이브러리에 있다.)

훌륭하다! 중복된 결과 없이 약수들의 쌍을 구해낼 수 있었다.

## Do 표기법

여기서 코드 가독성을 더 향상시킬 수 있다. `map`, `concatMap` 함수는 워낙 기본적이어서 (사실 이 함수들을 더 일반화시킨 `map`과 `bind` 함수는) **do 표기법**이라고 하는 특별한 문법을 사용하는데 기본 요건이다.

**주의**: `map`과 `concatMap`을 사용하여 **배열 다루기**를 할 수 있는 것처럼 이 함수들을 더 일반화한 `map`과 `bind` 함수를 사용하여 **모나드 다루기**를 할 수도 있다. 모나드는 이 책 뒤에서 더 다양한 예제들과 함께 살펴보기로 하고, 여기서는 배열만 다룰 것이다.

`factors` 함수는 do 표기법으로 고쳐쓸 수 있다.

```haskell
factors :: Int -> Array (Array Int)
factors n = filter (\xs -> product xs == n) $ do
  i <- 1 .. n
  j <- i .. n
  pure [i, j]
```

`do` 키워드에 이어지는 코드 블록은 몇 가지 형식을 따른다.

- 배열 요소들을 이름에 바인드하는 표현식. `<-` 역화살표 왼쪽에 바인드되는 이름이, 오른쪽에 배열(로 계산되는) 표현식이 나타난다.
- 배열 요소를 바인드하지 않는 표현식. 예를 들어 마지막 줄의 `pure [i, j]` 같은 표현식.
- `let` 키워드를 이용하여 어떤 표현식을 이름에 바인드하는 표현식.

이러한 새 표기법은 알고리즘 구조를 더 명료하게 보여준다. `<-` 역화살표를 "... 중에서 고르기" 정도로 읽을 수 있는데, 그러면 위 정의를 다음처럼 읽을 수 있다.
"`i`를 1부터 `n`에서 고르고, `j`를 `i`부터 `n` 사이에서 고르고, `[i, j]`를 반환한다."

마지막 줄에 사용된 `pure` 함수를 PSCi에서 살펴보려면 타입을 추가로 표기해줘야 한다.

```text
> pure [1, 2] :: Array (Array Int)
[[1, 2]]
```

배열의 경우 `pure`는 인자를 하나 가지는 싱글턴 배열을 만들어준다.
사실 `factor` 함수에서는 `pure`를 사용하는 대신 이중 배열을 사용해도 된다.

```haskell
factors :: Int -> Array (Array Int)
factors n = filter (\xs -> product xs == n) $ do
  i <- 1 .. n
  j <- i .. n
  [[i, j]]
```

결과는 똑같다.

## 가드: 조건 검사

한 걸음 더 나아가보자. 배열 다루기 중에 필터링을 할 수도 있다.
`Control.MonadZero` 모듈에 정의된 `guard` 함수를 이용하면 된다.(`purescript-control` 패키지)

```haskell
import Control.MonadZero (guard)

factors :: Int -> Array (Array Int)
factors n = do
  i <- 1 .. n
  j <- i .. n
  guard $ i * j == n
  pure [i, j]
```

`pure`와 마찬가지로 `guard` 함수를 PSCi에서 따로 확인해 볼 수 있다.
`guard` 함수의 타입은 배열을 다루는 것을 넘어 더 일반화되어 있다.

```text
> import Control.MonadZero

> :type guard
forall m. MonadZero m => Boolean -> m Unit
```

우리 경우는 다음의 타입을 가진다고 가정하자.

```haskell
Boolean -> Array Unit
```

배열 다루기에서의  `guard` 역할은 아래처럼 실행시켜 보면 명확해진다.

```text
> import Data.Array

> length $ guard true
1

> length $ guard false
0
```

`guard`에 전달된 표현식, 혹은 조건이 `true`가 되면 길이가 1인 배열을 반환하고, `false`가 되면 비어있는 배열을 반환한다.

즉, 조건 검사가 실패하면 진행 중인 배열 다루기 줄기를 더이상 진행하지 결과 없이 종료한다. 중간 결과로 생성되는 배열에 대해 `filter`를 적용한 것과 같은 결과를 낳는다. 상황에 따라 `filter`를 쓰거나 그 대신 `guard`를 쓸 수 있다. 두 가지 버전의 `factors` 함수가 똑같이 동작하는지 확인해보라.

> ## 연습 문제
>
> 1. (쉬움) `factors` 함수를 이용하여 소수인지 판별하는 `isPrime` 함수를 작성해보라.
> 1. (보통) do 표기법을 써서 두 배열의 **완전 곱(cartesian product)**을 계산하는 함수를 작성해보라.
> 1. (보통) `a² + b² = c²`를 만족하는 `[a, b, c]`를 **피타고라스 삼조**라고 한다. `guard` 함수를 사용하는 배열 다루기를 이용하여 주어진 수 `n`보다 작은 수들로 된 모든 피타고라스 삼조를 계산하는 `triples` 함수를 작성해보라. 이 함수의 타입을 `Int -> Array (Array Int)`로 한다.
> 1. (어려움) 어떤 정수 `n`에 대해 가능한 모든 인수 분해를 계산하는 `factorizations` 함수를 작성해보라. **힌트**: 1보다 큰 정수에 대해서는 첫 번째 인수를 찾는 문제와 남은 인수들을 찾는 문제로 나눠서 접근할 수 있다.

## Fold: 접고 포개기

배열을 왼쪽으로 접어가는 것과 오른쪽으로 접어가는 fold 함수들이 있다. 재귀로 구현되는 재미난 함수들이다.

`Data.Foldable` 모듈을 임포트하여 `foldl`과 `foldr` 함수의 타입부터 알아보자.

```text
> import Data.Foldable

> :type foldl
forall a b f. Foldable f => (b -> a -> b) -> b -> f a -> b

> :type foldr
forall a b f. Foldable f => (a -> b -> b) -> b -> f a -> b
```

이번에도 타입이 꽤 일반적이지만 지금 우리가 관심을 가지는 배열에 대해 적용해보면 대략 아래와 같은 타입을 가진다고 볼 수 있다.

```text
> :type foldl
forall a b. (b -> a -> b) -> b -> Array a -> b

> :type foldr
forall a b. (a -> b -> b) -> b -> Array a -> b
```

두 함수 모두 `a`는 배열 요소들의 타입을 말하고, `b`는 계산 결과를 쌓아가는 "누적값"의 타입이다. `b`는 배열 전체를 다 처리한 후 반환하는 결과 타입이기도 하다.

`foldl`과 `foldr`의 차이는 배열을 접어가는 방향이다. `foldl`은 "왼쪽부터" 접어가고, `foldr`은 "오른쪽부터" 접어간다.

이 함수들이 어떤 식으로 사용되는지 살펴보자. `foldl`을 사용하여 숫자 배열의 합을 계산할 수 있다. 그러면 `a` 타입은 `Int`가 되고, 결과 타입인 `b` 역시 `Int`가 된다. 인자가 세 개 필요한데, 첫 번째 인자인 `Int -> Int -> Int` 타입의 함수는 누적값에 배열 요소를 하나씩 더하는 일을 하고, 두 번째 인자는 `Int` 타입으로 누적값의 최초 값(혹은 기본 값)을 의미하며, 세 번째 인자는 합을 계산할 `Int`의 배열이다. 첫 번째 인자에는 덧셈 연산자를 사용하면 되고, 초기 누적값은 0을 사용하면 된다.

```text
> foldl (+) 0 (1 .. 5)
15
```

이 경우는 `foldl`을 쓰나 `foldr`을 쓰나 결과가 다르지 않다. 합을 계산하는데 더하는 순서가 중요하지 않기 때문이다.

```text
> foldr (+) 0 (1 .. 5)
15
```

두 함수의 차이를 드러내기 위해 접어가는 방향이 중요한 예를 살펴보자. 문자열을 이어붙이는 경우가 여기에 해당한다.

```text
> foldl (\acc n -> acc <> show n) "" [1,2,3,4,5]
"12345"

> foldr (\n acc -> acc <> show n) "" [1,2,3,4,5]
"54321"
```

두 함수의 차이가 드러난다. 위의 코드에서 왼쪽으로 접어가는 경우는 아래와 같고,

```text
((((("" <> show 1) <> show 2) <> show 3) <> show 4) <> show 5)
```

오른쪽으로 접어가는 경우는 아래와 같다.

```text
((((("" <> show 5) <> show 4) <> show 3) <> show 2) <> show 1)
```

## 꼬리 재귀

재귀는 알고리즘을 나타낼 때는 강력한 힘을 발휘하지만 문제가 없지 않다. JavaScript에서 재귀 함수를 계산할 때 입력이 큰 경우 스택 오버플로 에러가 발생할 수 있다.

이 문제는 PSCi에서 쉽게 확인할 수 있다.

```text
> f 0 = 0
> f n = 1 + f (n - 1)

> f 10
10

> f 100000
RangeError: Maximum call stack size exceeded
```

문제가 확실하다. 함수형 프로그래밍에서 재귀를 표준적 기술로 채용하려면 이 문제에 대한 해법이 필요하다.

PureScript는 **꼬리 재귀 최적화**라는 형식으로 부분적인 해법을 제공한다.

**주의**: **트램폴리닝**이라고 하는 좀더 완전한 해법이 라이브러리로 구현되어 있다. 하지만 이 장에서 다루기엔 벅찬 내용이다. 관심있는 독자는 `purescript-free`와 `purescript-tailrec` 패키지의 문서를 참고해보기 바란다.

꼬리 재귀 최적화가 가능한 경우는 제한적이다. 어떤 함수의 **꼬리 위치**에서 재귀 호출이 발생하면 **점프**로 대신하여 스택 프레임 할당을 피할 수 있다는 점이 꼬리 재귀 최적화의 핵심이다. **꼬리 위치**에서의 함수 호출이라는 것은 그 호출의 결과를 바로 반환하는 경우를 말한다. 앞의 예제에서 스택 오버플로가 발생한 이유는 `f` 재귀 호출의 위치가 꼬리가 아니었기 때문이다.

실제로 PureScript 컴파일러가 꼬리 재귀 호출을 점프로 바꾸는 것은 아니고 재귀 함수 전체를 **while 반복문**으로 만든다.

다음 예제는 재귀 호출이 꼬리 위치에 있는 경우다.

```haskell
fact :: Int -> Int -> Int
fact 0 acc = acc
fact n acc = fact (n - 1) (acc * n)
```

`fact` 재귀 호출의 결과가 그대로 결과값이 된다는 걸 알 수 있다. 그것이 바로 꼬리 위치다.

## 누적값

꼬리 재귀가 아닌 재귀 함수를 꼬리 재귀로 바꾸는 일반적인 방법이 **누적값 파라미터**를 이용하는 것이다.
재귀 함수가 재귀 호출로 계산한 값을 누적 계산하여 반환하는 대신 함수에 추가된 누적값 파라미터를 이용하여 누적 계산해 나가는 방식이다.

예를 들어 입력 배열을 거꾸로 뒤집는 재귀 함수를 보자. 이 함수는 입력된 배열을 머리와 꼬리를 따로 떼어낸 다음 재귀적으로 꼬리를 뒤집고 그 뒤에 머리를 붙인다.

```haskell
reverse :: forall a. Array a -> Array a
reverse [] = []
reverse xs = snoc (reverse (unsafePartial tail xs))
                  (unsafePartial head xs)
```

이 구현은 꼬리 재귀가 아니다. 따라서 컴파일러가 생성한 JavaScript는 입력 배열이 매우 큰 경우에 스택 오버플로를 발생할 수 있다. 하지만 이 함수에 결과를 누적시켜 나갈 인자를 추가하여 꼬리 재귀로 바꿀 수 있다.

```haskell
reverse :: forall a. Array a -> Array a
reverse = reverse' []
  where
    reverse' acc [] = acc
    reverse' acc xs = reverse' (unsafePartial head xs : acc)
                               (unsafePartial tail xs)
```

`reverse'` 도움 함수를 만들어서 실제 배열을 뒤집는 일을 이 함수가 처리한다. 이제는 `reverse'` 함수가 꼬리 재귀 함수가 되었다. 생성되는 코드에는 **while 반복문**으로 나타날 것이고 입력이 크더라도 스택을 날려버릴 일은 없을 것이다.

새로 구현한 `reverse` 함수를 이해하려면 `reverse'` 도움 함수가 상태를 저장하기 위해 누적값 파라미터를 사용하고 있음을 눈여겨봐야 한다. 이 누적값 파라미터는 빈 배열로 시작하여 입력 배열의 요소들을 하나씩 더해 나간다. 이 때 추가되는 요소가 누적값 배열의 앞쪽으로 추가되므로 최종 결과는 입력 배열이 뒤집어진 형태가 된다.

누적값을 "상태"라고 생각할 수 있지만 여전히 직접적으로 값을 변경하는 것은 아니다. 누적값은 변경할 수 없는 배열이며 계산 과정의 상태 변화는 함수 인자를 이용하여 이뤄진다.

## 재귀보다 Fold

꼬리 재귀로 재귀 함수를 작성할 수 있다면 꼬리 재귀 최적화의 이득을 취할 수 있다. 재귀 함수를 더 적극적으로 사용할 명분이 된다. 하지만 배열이나 그와 유사한 다른 자료 구조들에 대해 재귀로 작성할 수 있는 함수들 중 상당수는 fold로 구현할 수도 있다. 알고리즘을 `map`이나 `fold`의 조합으로 나타내면 코드가 더 단순해진다는 이득이 더해진다. 왜냐하면 이 함수들(혹은 컴비네이터라도 부른다.)은 워낙 기본적이고 널리 알려져 있기 때문에 직접적인 재귀 구현보다 알고리즘의 **의도**를 더 분명하게 드러낼 수 있다.

앞에서 본 `reverse` 예제도 두 가지 방식으로 fold를 사용하여 작성할 수 있다. 먼저 `foldr`을 사용하는 구현을 보자.

```text
> import Data.Foldable

> :paste
… reverse :: forall a. Array a -> Array a
… reverse = foldr (\x xs -> xs <> [x]) []
… ^D

> reverse [1, 2, 3]
[3,2,1]
```

`foldl`로 `reverse`를 구현하는 것은 독자를 위한 연습 문제로 남겨둔다.

> ## 연습 문제
>
> 1. (쉬움) `foldl`을 이용하여 배열의 모든 값들이 참인지 확인해보라.
> 1. (보통) `foldl (==) false xs`가 참인 배열 `xs`는 어떤 배열일까?
> 1. (보통) 다음 함수를 누적값 파라미터를 사용하는 꼬리 재귀 함수로 바꿔보라.
>
>     ```haskell
>     import Prelude
>     import Data.Array.Partial (head, tail)
>
>     count :: forall a. (a -> Boolean) -> Array a -> Int
>     count _ [] = 0
>     count p xs = if p (unsafePartial head xs)
>                    then count p (unsafePartial tail xs) + 1
>                    else count p (unsafePartial tail xs)
>     ```
>
> 1. (보통) `reverse`를 `foldl`로 구현해보라.

## 가상 파일 시스템

이 절에서는 지금까지 배운 내용을 응용하여 파일 시스템 모델을 다루기 위한 함수를 작성해보겠다. 이미 정의된 API 위에서 `map`, `fold`, `filter`를 사용할 것이다.

`Data.Path` 모듈에는 가상의 파일 시스템에 대한 API가 아래와 같이 정의되어 있다.

- `Path` 타입은 파일 시스템의 경로(혹은 패스)를 나타낸다.
- `root` 패스는 루트 디렉터리를 나타낸다.
- `ls` 함수는 주어진 `Path`에서 파일들의 목록을 반환한다.
- `filename` 함수는 주어진 `Path`에서 파일 이름만 반환한다.
- `size` 함수는 주어진 `Path`가 가리키는 파일의 크기를 반환한다.
- `isDirectory` 함수는 주어진 패스가 가리키는 것이 파일인지 디렉터리인지 판별한다.

타입을 보면 아래와 같다.

```haskell
root :: Path

ls :: Path -> Array Path

filename :: Path -> String

size :: Path -> Maybe Number

isDirectory :: Path -> Boolean
```

PSCi에서 API를 살펴볼 수 있다.

```text
$ pulp psci

> import Data.Path

> root
/

> isDirectory root
true

> ls root
[/bin/,/etc/,/home/]
```

`FileOperations` 모듈은 `Data.Path` API를 사용하는 함수들을 정의한다. 여러분은 `Data.Path`를 수정하거나 구현을 들여다 볼 필요는 없다.
`FileOperations` 모듈이 우리 작업 영역이다.

## 모든 파일 리스트 보기

어떤 디렉터리 아래의 모든 파일들을 리스트로 반환하는 함수를 작성해보자. 이 함수는 아래와 같은 타입을 가질 것이다.

```haskell
allFiles :: Path -> Array Path
```

이 함수는 재귀로 구현할 수 있다. 먼저 `ls`로 현재 디렉터리에 직접 포함된 자식들을 나열할 수 있다. 각 자식 항목에 대해 재귀적으로 `allFiles`를 적용한다.
재귀 호출의 결과는 패스의 배열이므로 `concatMap`을 사용하여 `allFiles`를 적용하면서 동시에 그 결과를 납작하게 펼칠 수 있다.

마지막으로 `:` 연산자를 이용하여 현재 파일을 결과에 포함시킨다.

```haskell
allFiles file = file : concatMap allFiles (ls file)
```

**주의**: `:` 연산자("cons"라고 읽는다)는 불변 배열에 대해 성능이 매우 나쁘기 때문에 일반적으로는 잘 사용하지 않는다. 성능을 개선하려면 연결 리스트나 시퀀스 같은 다른 자료 구조를 사용하면 된다.

PSCi에서 이 함수를 테스트해보자.

```text
> import FileOperations
> import Data.Path

> allFiles root

[/,/bin/,/bin/cp,/bin/ls,/bin/mv,/etc/,/etc/hosts, ...]
```

좋다. 일단 결과가 잘 나오는 것은 확인했다. 이제 이 함수를 do 표기법을 사용하여 배열 다루기로 구현할 수 있는지 살펴보자.

역화살표를 사용하여 배열에서 요소를 하나씩 추출할 수 있었다는 걸 기억하자. 첫 단계는 인자로 전달받은 경로의 직접 자식들을 하나씩 꺼낸다.
자식 파일에 대해 재귀 호출한다. do 표기법에서는 `concatMap`을 가정하고 있기 때문에 재귀 호출의 결과는 자동으로 모두 연결된다.

이렇게 새로 구현한 함수는 다음과 같다.

```haskell
allFiles' :: Path -> Array Path
allFiles' file = file : do
  child <- ls file
  allFiles' child
```

새 구현도 PSCi에서 테스트해보자. 이전 버전과 같은 결과가 나와야 한다. 둘 중에서 어느 구현이 더 깔끔한지는 여러분의 판단에 맡긴다.

> ## 연습 문제
>
> 1. (쉬움) 어떤 디렉터리의 모든 자식들 중에서 디렉터리를 제외한 모든 파일을 반환하는 `onlyFiles` 함수를 작성해보라.
> 1. (보통) fold를 써서 파일 시스템 전체 중 가장 큰 파일과 가장 작은 파일을 찾아보라.
> 1. (어려움) 이름으로 파일을 찾아주는 `whereIs` 함수를 작성해보라. 그 이름의 파일이 있는 경우 파일을 포함하는 디렉터리를 반환하기 위해 `Maybe Path` 타입을 반환해야 한다. 아래처럼 동작하면 된다.
>
>     ```text
>     > whereIs "/bin/ls"
>     Just (/bin/)
>
>     > whereIs "/bin/cat"
>     Nothing
>     ```
>
>     **힌트**: do 표기법을 이용하여 배열 다루기로 구현할 수 있다.

## 결론

이 장에서는 PureScript에서의 재귀에 대해 기본적인 내용들을 살펴봤다. 재귀는 알고리즘을 간결하게 표현할 수 있는 수단이다. 사용자가 직접 정의하는 중위 연산자를 비롯하여 `map`, `filter`, `fold`와 같은 표준 함수들, 그리고 이 함수들을 모두 종합하는 배열 다루기 등도 살펴봤다. 마지막으로 스택 오버플로 에러를 회피하기 위한 꼬리 재귀의 중요성을 짚어봤고, 누적값 파라미터를 이용하여 꼬리 재귀 함수로 만드는 방법도 살펴봤다.
